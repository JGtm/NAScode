#!/bin/bash

###########################################################
# SCRIPT DE CONVERSION VID√âO LIBX265
# Version modulaire - Point d'entr√©e principal
###########################################################
# 
# Ce script convertit des fichiers vid√©o en HEVC/x265 avec
# encodage two-pass pour une taille pr√©visible (~1,1 Go/h).
#
# Architecture modulaire :
#   lib/ui.sh     - Codes couleurs ANSI
#   lib/config.sh     - Configuration globale et param√®tres
#   lib/utils.sh      - Fonctions utilitaires (MD5, timestamps, etc.)
#   lib/logging.sh    - Gestion des logs et r√©pertoires
#   lib/lock.sh       - Gestion des verrous et cleanup
#   lib/system.sh     - V√©rifications syst√®me et d√©pendances
#   lib/args.sh       - Parsing des arguments CLI
#   lib/queue.sh      - Construction et gestion de la file d'attente
#   lib/progress.sh   - Syst√®me de slots pour progression parall√®le
#   lib/media_probe.sh - Propri√©t√©s m√©dia (ffprobe)
#   lib/transcode_video.sh - Transcodage vid√©o (x265, 10-bit/downscale)
#   lib/conversion.sh - Logique de conversion FFmpeg
#   lib/processing.sh - Traitement parall√®le et FIFO
#   lib/vmaf.sh       - Analyse VMAF (qualit√© vid√©o)
#   lib/finalize.sh   - Finalisation et r√©sum√©
#   lib/exports.sh    - Export des fonctions/variables pour sous-shells
#
###########################################################

set -euo pipefail

###########################################################
# D√âTERMINATION DU R√âPERTOIRE DU SCRIPT
###########################################################

# Le SCRIPT_DIR est le r√©pertoire contenant ce script
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LIB_DIR="$SCRIPT_DIR/lib"

###########################################################
# CHARGEMENT DES MODULES
###########################################################

# V√©rifier que le r√©pertoire lib existe
if [[ ! -d "$LIB_DIR" ]]; then
    echo "ERREUR : R√©pertoire lib introuvable : $LIB_DIR"
    echo "Assurez-vous que tous les modules sont pr√©sents dans le dossier lib/"
    exit 1
fi

# Charger les modules dans l'ordre des d√©pendances
source "$LIB_DIR/ui.sh"           # Codes couleurs (pas de d√©pendances)
source "$LIB_DIR/ui_options.sh"   # Formatage options UI (d√©pend de ui.sh)
source "$LIB_DIR/detect.sh"       # D√©tection outils/syst√®me (d√©pend de rien, modifie PATH)
source "$LIB_DIR/config.sh"       # Configuration (d√©pend de colors pour erreurs)
source "$LIB_DIR/codec_profiles.sh" # Profils codecs (d√©pend de config pour VIDEO_CODEC)
source "$LIB_DIR/utils.sh"        # Utilitaires (d√©pend de detect pour HAS_*)
source "$LIB_DIR/logging.sh"      # Logs (d√©pend de config pour EXECUTION_TIMESTAMP)
source "$LIB_DIR/progress.sh"     # Slots progression (d√©pend de config pour EXECUTION_TIMESTAMP)
source "$LIB_DIR/lock.sh"         # Verrous (d√©pend de colors, config)
source "$LIB_DIR/system.sh"       # Syst√®me (d√©pend de colors, config, utils)
source "$LIB_DIR/off_peak.sh"     # Heures creuses (d√©pend de colors, config)
source "$LIB_DIR/args.sh"         # Arguments (d√©pend de colors, config, off_peak pour parse_off_peak_range)
source "$LIB_DIR/index.sh"        # Index fichiers (d√©pend de ui, utils)
source "$LIB_DIR/counters.sh"     # Compteurs persistants (d√©pend de config)
source "$LIB_DIR/queue.sh"        # Queue (d√©pend de index, counters, ui, config, utils, logging)
source "$LIB_DIR/vmaf.sh"         # VMAF (d√©pend de colors, config, utils, logging)
source "$LIB_DIR/media_probe.sh"  # Propri√©t√©s m√©dia (d√©pend de utils)
source "$LIB_DIR/complexity.sh"   # Analyse complexit√© pour film-adaptive (d√©pend de media_probe)
source "$LIB_DIR/audio_params.sh" # Param√®tres audio (d√©pend de config, utils)
source "$LIB_DIR/video_params.sh" # Param√®tres vid√©o (pix_fmt/downscale/bitrate/suffix)
source "$LIB_DIR/stream_mapping.sh" # Mapping streams (sous-titres)
source "$LIB_DIR/skip_decision.sh"  # Logique skip/passthrough/full (d√©pend de codec_profiles, ui)
source "$LIB_DIR/conversion_prep.sh" # Pr√©paration conversion (d√©pend de utils, ui, media_probe)
source "$LIB_DIR/adaptive_mode.sh"  # Mode film-adaptive (d√©pend de complexity, video_params, skip_decision)
source "$LIB_DIR/transcode_video.sh" # Encodage vid√©o (params, VBV, filtres)
source "$LIB_DIR/ffmpeg_pipeline.sh" # Pipeline FFmpeg (ex√©cution unifi√©e)
source "$LIB_DIR/conversion.sh"   # Orchestration conversion (d√©pend de tout ci-dessus)
source "$LIB_DIR/processing.sh"   # Traitement (d√©pend de conversion, queue, off_peak)
source "$LIB_DIR/summary.sh"      # R√©sum√© final (d√©pend de ui, utils, vmaf)
source "$LIB_DIR/finalize.sh"     # Finalisation (d√©pend de summary, ui, config, utils, vmaf)
source "$LIB_DIR/transfer.sh"     # Transferts asynchrones (d√©pend de finalize, config)
source "$LIB_DIR/exports.sh"      # Exports (d√©pend de tout)

###########################################################
# FONCTION PRINCIPALE
###########################################################

main() {
    # Configurer les traps pour le nettoyage
    setup_traps

    # Chrono global (temps total d'ex√©cution du script)
    # D√©fini une seule fois, et utilis√© dans le r√©sum√© final.
    if [[ -z "${START_TS_TOTAL:-}" ]]; then
        START_TS_TOTAL="$(date +%s)"
    fi
    
    # Parser les arguments de la ligne de commande
    parse_arguments "$@"
    
    # Configurer les param√®tres selon le mode de conversion
    set_conversion_mode_parameters
    
    # Mode fichier unique : traiter directement sans index/queue
    if [[ -n "${SINGLE_FILE:-}" ]]; then
        # Convertir en chemin absolu (robuste aux espaces)
        local single_file_input="$SINGLE_FILE"
        if ! SINGLE_FILE="$(abspath_path "$single_file_input")"; then
            echo -e "${RED}‚ùå ERREUR: Chemin de fichier invalide : $single_file_input${NOCOLOR}"
            exit 1
        fi

        # Valider l'entr√©e
        if [[ ! -f "$SINGLE_FILE" ]]; then
            echo -e "${RED}‚ùå ERREUR: Le fichier source n'existe pas : $SINGLE_FILE${NOCOLOR}"
            exit 1
        fi

        # SOURCE = dossier contenant le fichier (pour les chemins relatifs)
        SOURCE="$(dirname "$SINGLE_FILE")"
        
        # V√©rifications minimales
        check_lock
        check_dependencies
        initialize_directories
        init_async_transfers

        # V√©rification interactive du suffixe de sortie (coh√©rent avec le mode batch)
        check_output_suffix

        detect_hwaccel
        check_vmaf
        export_variables
        
        # Conversion directe du fichier unique
        if [[ "$NO_PROGRESS" != true ]]; then
            print_conversion_start 1
        fi
        
        convert_file "$SINGLE_FILE" "$OUTPUT_DIR"
        
        cleanup_transfers
        
        if [[ "$DRYRUN" != true ]]; then
            show_summary
        fi
        return
    fi
    
    # V√©rifier que SOURCE existe avant de convertir en chemin absolu
    if [[ ! -d "$SOURCE" ]]; then
        echo -e "${RED}‚ùå ERREUR: Le r√©pertoire source n'existe pas : $SOURCE${NOCOLOR}"
        exit 1
    fi
    SOURCE=$(cd "$SOURCE" && pwd)
    
    # V√©rifications initiales
    check_lock
    check_dependencies
    initialize_directories
    
    # Initialiser le syst√®me de transferts asynchrones
    init_async_transfers
    
    # V√©rifications interactives
    check_plexignore
    check_output_suffix
    
    # D√©tecter le hwaccel avant d'indexer / construire la queue
    detect_hwaccel

    # V√©rifier si VMAF est activ√© et disponible
    check_vmaf

    # Construire la file d'attente (peut poser des questions sur l'index)
    build_queue
    
    # Exporter les variables et fonctions pour les sous-shells
    export_variables

    # --- Apr√®s toutes les questions interactives ---
    # Afficher les informations heures creuses si activ√©
    show_off_peak_startup_info
    
    # Si mode heures creuses, attendre le d√©but des heures creuses avant de continuer
    if ! check_off_peak_before_processing; then
        echo -e "${RED}Arr√™t demand√© avant le d√©but du traitement.${NOCOLOR}"
        exit 0
    fi

    # Pr√©parer la queue dynamique, lancer le traitement et attendre la fin
    prepare_dynamic_queue

    # Attendre la fin de tous les transferts en cours
    cleanup_transfers

    # Afficher le r√©sum√© final
    if [[ "$DRYRUN" == true ]]; then
        dry_run_compare_names
        print_header "üß™ Dry run termin√©" "$GREEN"
    else
        show_summary
    fi
}

###########################################################
# POINT D'ENTR√âE
###########################################################

main "$@"
