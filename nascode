#!/bin/bash

###########################################################
# SCRIPT DE CONVERSION VIDÉO LIBX265
# Version modulaire - Point d'entrée principal
###########################################################
# 
# Ce script convertit des fichiers vidéo en HEVC/x265 avec
# encodage two-pass pour une taille prévisible (~1,1 Go/h).
#
# Architecture modulaire :
#   lib/ui.sh     - Codes couleurs ANSI
#   lib/config.sh     - Configuration globale et paramètres
#   lib/utils.sh      - Fonctions utilitaires (MD5, timestamps, etc.)
#   lib/logging.sh    - Gestion des logs et répertoires
#   lib/lock.sh       - Gestion des verrous et cleanup
#   lib/system.sh     - Vérifications système et dépendances
#   lib/args.sh       - Parsing des arguments CLI
#   lib/queue.sh      - Construction et gestion de la file d'attente
#   lib/progress.sh   - Système de slots pour progression parallèle
#   lib/media_probe.sh - Propriétés média (ffprobe)
#   lib/transcode_video.sh - Transcodage vidéo (x265, 10-bit/downscale)
#   lib/conversion.sh - Logique de conversion FFmpeg
#   lib/processing.sh - Traitement parallèle et FIFO
#   lib/vmaf.sh       - Analyse VMAF (qualité vidéo)
#   lib/finalize.sh   - Finalisation et résumé
#   lib/exports.sh    - Export des fonctions/variables pour sous-shells
#
###########################################################

set -euo pipefail

###########################################################
# DÉTERMINATION DU RÉPERTOIRE DU SCRIPT
###########################################################

# Le SCRIPT_DIR est le répertoire contenant ce script
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LIB_DIR="$SCRIPT_DIR/lib"

###########################################################
# CHARGEMENT DES MODULES
###########################################################

# Vérifier que le répertoire lib existe
if [[ ! -d "$LIB_DIR" ]]; then
    echo "ERROR / ERREUR : lib directory not found / Répertoire lib introuvable : $LIB_DIR"
    echo "Make sure all modules are present in lib/ / Assurez-vous que tous les modules sont présents dans lib/"
    exit 1
fi

# Charger l'internationalisation en premier (avant tout message utilisateur)
# Note: i18n.sh charge automatiquement la locale selon NASCODE_LANG ou --lang
source "$LIB_DIR/i18n.sh"

# Auto-charger un fichier d'environnement local (optionnel)
# Remarque: implémentation dans lib/env.sh (sans `source` du .env)
if [[ -f "$LIB_DIR/env.sh" ]]; then
    # shellcheck disable=SC1090
    source "$LIB_DIR/env.sh"
    if declare -f _nascode_autoload_env >/dev/null 2>&1; then
        _nascode_autoload_env "$SCRIPT_DIR"
    fi
fi

# Charger les modules dans l'ordre des dépendances
source "$LIB_DIR/constants.sh"    # Constantes globales (pas de dépendances, overridables)
source "$LIB_DIR/ui.sh"           # Codes couleurs (pas de dépendances)
source "$LIB_DIR/ui_options.sh"   # Formatage options UI (dépend de ui.sh)
source "$LIB_DIR/detect.sh"       # Détection outils/système (dépend de rien, modifie PATH)
source "$LIB_DIR/config.sh"       # Configuration (dépend de colors pour erreurs)
source "$LIB_DIR/codec_profiles.sh" # Profils codecs (dépend de config pour VIDEO_CODEC)
source "$LIB_DIR/utils.sh"        # Utilitaires (dépend de detect pour HAS_*)
source "$LIB_DIR/logging.sh"      # Logs (dépend de config pour EXECUTION_TIMESTAMP)
source "$LIB_DIR/notify.sh"       # Notifications externes (Discord, etc.) — best-effort
source "$LIB_DIR/progress.sh"     # Slots progression (dépend de config pour EXECUTION_TIMESTAMP)
source "$LIB_DIR/lock.sh"         # Verrous (dépend de colors, config)
source "$LIB_DIR/system.sh"       # Système (dépend de colors, config, utils)
source "$LIB_DIR/off_peak.sh"     # Heures creuses (dépend de colors, config)
source "$LIB_DIR/args.sh"         # Arguments (dépend de colors, config, off_peak pour parse_off_peak_range)
source "$LIB_DIR/index.sh"        # Index fichiers (dépend de ui, utils)
source "$LIB_DIR/counters.sh"     # Compteurs persistants (dépend de config)
source "$LIB_DIR/queue.sh"        # Queue (dépend de index, counters, ui, config, utils, logging)
source "$LIB_DIR/vmaf.sh"         # VMAF (dépend de colors, config, utils, logging)
source "$LIB_DIR/media_probe.sh"  # Propriétés média (dépend de utils)
source "$LIB_DIR/complexity.sh"   # Analyse complexité pour mode adaptatif (dépend de media_probe)
source "$LIB_DIR/audio_decision.sh" # Décision audio smart (dépend de config, codec_profiles)
source "$LIB_DIR/audio_params.sh" # Paramètres audio (dépend de config, utils, audio_decision)
source "$LIB_DIR/video_params.sh" # Paramètres vidéo (pix_fmt/downscale/bitrate/suffix)
source "$LIB_DIR/stream_mapping.sh" # Mapping streams (sous-titres)
source "$LIB_DIR/skip_decision.sh"  # Logique skip/passthrough/full (dépend de codec_profiles, ui)
source "$LIB_DIR/conversion_prep.sh" # Préparation conversion (dépend de utils, ui, media_probe)
source "$LIB_DIR/adaptive_mode.sh"  # Mode adaptatif (dépend de complexity, video_params, skip_decision)
source "$LIB_DIR/transcode_video.sh" # Encodage vidéo (params, VBV, filtres)
source "$LIB_DIR/ffmpeg_pipeline.sh" # Pipeline FFmpeg (exécution unifiée)
source "$LIB_DIR/conversion.sh"   # Orchestration conversion (dépend de tout ci-dessus)
source "$LIB_DIR/processing.sh"   # Traitement (dépend de conversion, queue, off_peak)
source "$LIB_DIR/summary.sh"      # Résumé final (dépend de ui, utils, vmaf)
source "$LIB_DIR/finalize.sh"     # Finalisation (dépend de summary, ui, config, utils, vmaf)
source "$LIB_DIR/transfer.sh"     # Transferts asynchrones (dépend de finalize, config)
source "$LIB_DIR/exports.sh"      # Exports (dépend de tout)

###########################################################
# FONCTION PRINCIPALE
###########################################################

main() {
    # Configurer les traps pour le nettoyage
    setup_traps

    # Chrono global (temps total d'exécution du script)
    # Défini une seule fois, et utilisé dans le résumé final.
    if [[ -z "${START_TS_TOTAL:-}" ]]; then
        START_TS_TOTAL="$(date +%s)"
    fi
    
    # Parser les arguments de la ligne de commande
    parse_arguments "$@"
    
    # Configurer les paramètres selon le mode de conversion
    set_conversion_mode_parameters

    # Mode fichier unique : traiter directement sans index/queue
    if [[ -n "${SINGLE_FILE:-}" ]]; then
        # Convertir en chemin absolu (robuste aux espaces)
        local single_file_input="$SINGLE_FILE"
        if ! SINGLE_FILE="$(abspath_path "$single_file_input")"; then
            print_error "$(msg MSG_MAIN_PATH_INVALID "$single_file_input")"
            exit 1
        fi

        # Valider l'entrée
        if [[ ! -f "$SINGLE_FILE" ]]; then
            print_error "$(msg MSG_MAIN_FILE_NOT_EXIST "$SINGLE_FILE")"
            exit 1
        fi

        # SOURCE = dossier contenant le fichier (pour les chemins relatifs)
        SOURCE="$(dirname "$SINGLE_FILE")"
        
        # Vérifications minimales
        check_lock
        check_dependencies
        initialize_directories
        init_async_transfers

        # Vérification interactive du suffixe de sortie (cohérent avec le mode batch)
        check_output_suffix

        detect_hwaccel
        check_vmaf
        export_variables

        # Notification de démarrage (Discord) — best-effort.
        if declare -f notify_event &>/dev/null; then
            notify_event run_started || true
        elif declare -f notify_event_run_started &>/dev/null; then
            notify_event_run_started || true
        fi
        
        # Conversion directe du fichier unique
        if [[ "$NO_PROGRESS" != true ]]; then
            print_conversion_start 1
        fi
        
        convert_file "$SINGLE_FILE" "$OUTPUT_DIR"
        
        cleanup_transfers
        
        if [[ "$DRYRUN" != true ]]; then
            show_summary
        fi
        return
    fi
    
    # Vérifier que SOURCE existe avant de convertir en chemin absolu
    if [[ ! -d "$SOURCE" ]]; then
        print_error "$(msg MSG_MAIN_DIR_NOT_EXIST "$SOURCE")"
        exit 1
    fi
    SOURCE=$(cd "$SOURCE" && pwd)

    # Protection : si la source est elle-même dans les exclusions, le run ne peut pas produire de fichiers.
    # On sort explicitement pour éviter un comportement perçu comme un blocage.
    if is_excluded "$SOURCE"; then
        print_error "$(msg MSG_MAIN_SOURCE_EXCLUDED "$SOURCE")"
        exit 1
    fi
    
    # Vérifications initiales
    check_lock
    check_dependencies
    initialize_directories
    
    # Initialiser le système de transferts asynchrones
    init_async_transfers
    
    # Vérifications interactives
    check_plexignore
    check_output_suffix
    
    # Détecter le hwaccel avant d'indexer / construire la queue
    detect_hwaccel

    # Vérifier si VMAF est activé et disponible
    check_vmaf

    # Construire la file d'attente (peut poser des questions sur l'index)
    build_queue

    # Notification de démarrage (Discord) — best-effort.
    # Placée ici pour inclure l'aperçu de la file (après les paramètres actifs).
    if declare -f notify_event &>/dev/null; then
        notify_event run_started || true
    elif declare -f notify_event_run_started &>/dev/null; then
        notify_event_run_started || true
    fi
    
    # Exporter les variables et fonctions pour les sous-shells
    export_variables

    # --- Après toutes les questions interactives ---
    # Afficher les informations heures creuses si activé
    show_off_peak_startup_info
    
    # Si mode heures creuses, attendre le début des heures creuses avant de continuer
    if ! check_off_peak_before_processing; then
        print_warning "$(msg MSG_MAIN_STOP_BEFORE_PROC)"
        exit 0
    fi

    # Préparer la queue dynamique, lancer le traitement et attendre la fin
    prepare_dynamic_queue

    # Attendre la fin de tous les transferts en cours
    cleanup_transfers

    # Afficher le résumé final
    if [[ "$DRYRUN" == true ]]; then
        dry_run_compare_names
        print_header "$(msg MSG_MAIN_DRYRUN_DONE)" "$GREEN"
    else
        show_summary
    fi
}

###########################################################
# POINT D'ENTRÉE
###########################################################

main "$@"
