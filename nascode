#!/bin/bash

###########################################################
# SCRIPT DE CONVERSION VIDÃ‰O LIBX265
# Version modulaire - Point d'entrÃ©e principal
###########################################################
# 
# Ce script convertit des fichiers vidÃ©o en HEVC/x265 avec
# encodage two-pass pour une taille prÃ©visible (~1,1 Go/h).
#
# Architecture modulaire :
#   lib/ui.sh     - Codes couleurs ANSI
#   lib/config.sh     - Configuration globale et paramÃ¨tres
#   lib/utils.sh      - Fonctions utilitaires (MD5, timestamps, etc.)
#   lib/logging.sh    - Gestion des logs et rÃ©pertoires
#   lib/lock.sh       - Gestion des verrous et cleanup
#   lib/system.sh     - VÃ©rifications systÃ¨me et dÃ©pendances
#   lib/args.sh       - Parsing des arguments CLI
#   lib/queue.sh      - Construction et gestion de la file d'attente
#   lib/progress.sh   - SystÃ¨me de slots pour progression parallÃ¨le
#   lib/media_probe.sh - PropriÃ©tÃ©s mÃ©dia (ffprobe)
#   lib/transcode_video.sh - Transcodage vidÃ©o (x265, 10-bit/downscale)
#   lib/conversion.sh - Logique de conversion FFmpeg
#   lib/processing.sh - Traitement parallÃ¨le et FIFO
#   lib/vmaf.sh       - Analyse VMAF (qualitÃ© vidÃ©o)
#   lib/finalize.sh   - Finalisation et rÃ©sumÃ©
#   lib/exports.sh    - Export des fonctions/variables pour sous-shells
#
###########################################################

set -euo pipefail

###########################################################
# DÃ‰TERMINATION DU RÃ‰PERTOIRE DU SCRIPT
###########################################################

# Le SCRIPT_DIR est le rÃ©pertoire contenant ce script
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LIB_DIR="$SCRIPT_DIR/lib"

###########################################################
# CHARGEMENT DES MODULES
###########################################################

# VÃ©rifier que le rÃ©pertoire lib existe
if [[ ! -d "$LIB_DIR" ]]; then
    echo "ERREUR : RÃ©pertoire lib introuvable : $LIB_DIR"
    echo "Assurez-vous que tous les modules sont prÃ©sents dans le dossier lib/"
    exit 1
fi

# Auto-charger un fichier d'environnement local (optionnel)
# Remarque: implÃ©mentation dans lib/env.sh (sans `source` du .env)
if [[ -f "$LIB_DIR/env.sh" ]]; then
    # shellcheck disable=SC1090
    source "$LIB_DIR/env.sh"
    if declare -f _nascode_autoload_env >/dev/null 2>&1; then
        _nascode_autoload_env "$SCRIPT_DIR"
    fi
fi

# Charger les modules dans l'ordre des dÃ©pendances
source "$LIB_DIR/constants.sh"    # Constantes globales (pas de dÃ©pendances, overridables)
source "$LIB_DIR/ui.sh"           # Codes couleurs (pas de dÃ©pendances)
source "$LIB_DIR/ui_options.sh"   # Formatage options UI (dÃ©pend de ui.sh)
source "$LIB_DIR/detect.sh"       # DÃ©tection outils/systÃ¨me (dÃ©pend de rien, modifie PATH)
source "$LIB_DIR/config.sh"       # Configuration (dÃ©pend de colors pour erreurs)
source "$LIB_DIR/codec_profiles.sh" # Profils codecs (dÃ©pend de config pour VIDEO_CODEC)
source "$LIB_DIR/utils.sh"        # Utilitaires (dÃ©pend de detect pour HAS_*)
source "$LIB_DIR/logging.sh"      # Logs (dÃ©pend de config pour EXECUTION_TIMESTAMP)
source "$LIB_DIR/notify.sh"       # Notifications externes (Discord, etc.) â€” best-effort
source "$LIB_DIR/progress.sh"     # Slots progression (dÃ©pend de config pour EXECUTION_TIMESTAMP)
source "$LIB_DIR/lock.sh"         # Verrous (dÃ©pend de colors, config)
source "$LIB_DIR/system.sh"       # SystÃ¨me (dÃ©pend de colors, config, utils)
source "$LIB_DIR/off_peak.sh"     # Heures creuses (dÃ©pend de colors, config)
source "$LIB_DIR/args.sh"         # Arguments (dÃ©pend de colors, config, off_peak pour parse_off_peak_range)
source "$LIB_DIR/index.sh"        # Index fichiers (dÃ©pend de ui, utils)
source "$LIB_DIR/counters.sh"     # Compteurs persistants (dÃ©pend de config)
source "$LIB_DIR/queue.sh"        # Queue (dÃ©pend de index, counters, ui, config, utils, logging)
source "$LIB_DIR/vmaf.sh"         # VMAF (dÃ©pend de colors, config, utils, logging)
source "$LIB_DIR/media_probe.sh"  # PropriÃ©tÃ©s mÃ©dia (dÃ©pend de utils)
source "$LIB_DIR/complexity.sh"   # Analyse complexitÃ© pour mode adaptatif (dÃ©pend de media_probe)
source "$LIB_DIR/audio_decision.sh" # DÃ©cision audio smart (dÃ©pend de config, codec_profiles)
source "$LIB_DIR/audio_params.sh" # ParamÃ¨tres audio (dÃ©pend de config, utils, audio_decision)
source "$LIB_DIR/video_params.sh" # ParamÃ¨tres vidÃ©o (pix_fmt/downscale/bitrate/suffix)
source "$LIB_DIR/stream_mapping.sh" # Mapping streams (sous-titres)
source "$LIB_DIR/skip_decision.sh"  # Logique skip/passthrough/full (dÃ©pend de codec_profiles, ui)
source "$LIB_DIR/conversion_prep.sh" # PrÃ©paration conversion (dÃ©pend de utils, ui, media_probe)
source "$LIB_DIR/adaptive_mode.sh"  # Mode adaptatif (dÃ©pend de complexity, video_params, skip_decision)
source "$LIB_DIR/transcode_video.sh" # Encodage vidÃ©o (params, VBV, filtres)
source "$LIB_DIR/ffmpeg_pipeline.sh" # Pipeline FFmpeg (exÃ©cution unifiÃ©e)
source "$LIB_DIR/conversion.sh"   # Orchestration conversion (dÃ©pend de tout ci-dessus)
source "$LIB_DIR/processing.sh"   # Traitement (dÃ©pend de conversion, queue, off_peak)
source "$LIB_DIR/summary.sh"      # RÃ©sumÃ© final (dÃ©pend de ui, utils, vmaf)
source "$LIB_DIR/finalize.sh"     # Finalisation (dÃ©pend de summary, ui, config, utils, vmaf)
source "$LIB_DIR/transfer.sh"     # Transferts asynchrones (dÃ©pend de finalize, config)
source "$LIB_DIR/exports.sh"      # Exports (dÃ©pend de tout)

###########################################################
# FONCTION PRINCIPALE
###########################################################

main() {
    # Configurer les traps pour le nettoyage
    setup_traps

    # Chrono global (temps total d'exÃ©cution du script)
    # DÃ©fini une seule fois, et utilisÃ© dans le rÃ©sumÃ© final.
    if [[ -z "${START_TS_TOTAL:-}" ]]; then
        START_TS_TOTAL="$(date +%s)"
    fi
    
    # Parser les arguments de la ligne de commande
    parse_arguments "$@"
    
    # Configurer les paramÃ¨tres selon le mode de conversion
    set_conversion_mode_parameters

    # Mode fichier unique : traiter directement sans index/queue
    if [[ -n "${SINGLE_FILE:-}" ]]; then
        # Convertir en chemin absolu (robuste aux espaces)
        local single_file_input="$SINGLE_FILE"
        if ! SINGLE_FILE="$(abspath_path "$single_file_input")"; then
            print_error "ERREUR: Chemin de fichier invalide : $single_file_input"
            exit 1
        fi

        # Valider l'entrÃ©e
        if [[ ! -f "$SINGLE_FILE" ]]; then
            print_error "ERREUR: Le fichier source n'existe pas : $SINGLE_FILE"
            exit 1
        fi

        # SOURCE = dossier contenant le fichier (pour les chemins relatifs)
        SOURCE="$(dirname "$SINGLE_FILE")"
        
        # VÃ©rifications minimales
        check_lock
        check_dependencies
        initialize_directories
        init_async_transfers

        # VÃ©rification interactive du suffixe de sortie (cohÃ©rent avec le mode batch)
        check_output_suffix

        detect_hwaccel
        check_vmaf
        export_variables

        # Notification de dÃ©marrage (Discord) â€” best-effort.
        if declare -f notify_event &>/dev/null; then
            notify_event run_started || true
        elif declare -f notify_event_run_started &>/dev/null; then
            notify_event_run_started || true
        fi
        
        # Conversion directe du fichier unique
        if [[ "$NO_PROGRESS" != true ]]; then
            print_conversion_start 1
        fi
        
        convert_file "$SINGLE_FILE" "$OUTPUT_DIR"
        
        cleanup_transfers
        
        if [[ "$DRYRUN" != true ]]; then
            show_summary
        fi
        return
    fi
    
    # VÃ©rifier que SOURCE existe avant de convertir en chemin absolu
    if [[ ! -d "$SOURCE" ]]; then
        print_error "ERREUR: Le rÃ©pertoire source n'existe pas : $SOURCE"
        exit 1
    fi
    SOURCE=$(cd "$SOURCE" && pwd)

    # Protection : si la source est elle-mÃªme dans les exclusions, le run ne peut pas produire de fichiers.
    # On sort explicitement pour Ã©viter un comportement perÃ§u comme un blocage.
    if is_excluded "$SOURCE"; then
        print_error "ERREUR: Le rÃ©pertoire source est exclu par la configuration (EXCLUDES) : $SOURCE"
        exit 1
    fi
    
    # VÃ©rifications initiales
    check_lock
    check_dependencies
    initialize_directories
    
    # Initialiser le systÃ¨me de transferts asynchrones
    init_async_transfers
    
    # VÃ©rifications interactives
    check_plexignore
    check_output_suffix
    
    # DÃ©tecter le hwaccel avant d'indexer / construire la queue
    detect_hwaccel

    # VÃ©rifier si VMAF est activÃ© et disponible
    check_vmaf

    # Construire la file d'attente (peut poser des questions sur l'index)
    build_queue

    # Notification de dÃ©marrage (Discord) â€” best-effort.
    # PlacÃ©e ici pour inclure l'aperÃ§u de la file (aprÃ¨s les paramÃ¨tres actifs).
    if declare -f notify_event &>/dev/null; then
        notify_event run_started || true
    elif declare -f notify_event_run_started &>/dev/null; then
        notify_event_run_started || true
    fi
    
    # Exporter les variables et fonctions pour les sous-shells
    export_variables

    # --- AprÃ¨s toutes les questions interactives ---
    # Afficher les informations heures creuses si activÃ©
    show_off_peak_startup_info
    
    # Si mode heures creuses, attendre le dÃ©but des heures creuses avant de continuer
    if ! check_off_peak_before_processing; then
        print_warning "ArrÃªt demandÃ© avant le dÃ©but du traitement."
        exit 0
    fi

    # PrÃ©parer la queue dynamique, lancer le traitement et attendre la fin
    prepare_dynamic_queue

    # Attendre la fin de tous les transferts en cours
    cleanup_transfers

    # Afficher le rÃ©sumÃ© final
    if [[ "$DRYRUN" == true ]]; then
        dry_run_compare_names
        print_header "ğŸ§ª Dry run terminÃ©" "$GREEN"
    else
        show_summary
    fi
}

###########################################################
# POINT D'ENTRÃ‰E
###########################################################

main "$@"
